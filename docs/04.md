thin的机制====#4. 数据绑定数据绑定是一种很便捷的特性，一些RIA框架带有双向绑定功能，比如Flex和Silverlight，当某个数据发生变更时，所绑定的界面元素也发生变更，当界面元素的值发生变化时，数据也跟着变化，这种功能在处理表单数据的填充和收集时，是非常有用的。在HTML中，原生是没有这样的功能的，但有些框架做到了，它们是怎么做到的呢？我们来做个简单的试试，顺便探讨一下其中原理。先看看绑定怎么定义。在不少框架里，都在DOM元素上添加了一些自己的属性，比如我们打算用这种方式来定义绑定关系：    <input vm-model="name"/>这个代码的意思是，把name变量跟这个输入框的值建立一个双向绑定关系。现在我们的框架启动之后，要先把这种绑定关系收集起来，这种属性会分布于DOM的各个角落，一个很现实的做法是，递归遍历界面的每个DOM节点，检测该属性，于是我们代码的结构大致如下所示。	function parseElement(element) {		for (var i=0; i<element.attributes.length; i++) {			parseElement(element.attributes[i]);		}		for (var i=0; i<element.children.length; i++) {			parseElement(element.children[i]);		}	}但是我们这时候面临一个问题，比如你的输入框绑定在name变量上，这个name应该从属于什么？它是全局变量吗？我们在开始做这个框架的时候强调了一个原则：业务模块不允许定义全局变量，框架内部也尽量少有全局作用域，到目前为止，我们只暴露了thin一个全局入口，所以在这里不能破坏这个原则。因此，我们要求业务开发人员去定义一个视图模型，把变量包装起来，所包装的不限于变量，也可以有方法。比如下面，我们定义了一个实体叫Person，带两个变量，两个方法，后面我们来演示一下怎么把它们绑定到HTML界面。	thin.define("Person", [], function() {		function Person() {			this.name = "Tom";			this.age = 5;		}		Person.prototype = {			growUp: function() {				this.age++;			}		};		return Person;	});模型方面都准备好了，现在来看界面：	<div vm-model="Person">		<input type="text" vm-value="name"/>		<input type="text" vm-value="age"/>		<input type="button" vm-click="growUp" value="Grow Up"/>	</div>为了使得结构更加容易看，我们把界面的无关属性比如样式之类都去掉了，只留下不能再减少的这么一段。现在我们可以看到，在界面的顶层定义一个vm-model属性，值为实体的名称。两个输入框通过vm-value来绑定到实例属性，vm-init绑定界面的初始化方法，vm-click绑定按钮的点击事件。好了，现在我们可以来扫描这个简单的DOM结构了。想要做这么一个绑定，首先要考虑数据从哪里来？在绑定name和code属性之前，毫无疑问，应当先实例化一个Person，我们怎么才能知道需要把Person模块实例化呢？当扫描到一个DOM元素的时候，我们要先检测它的vm-model属性，如果有值，就取这个值来实例化，然后，把这个值一直传递下去，在扫描其他属性或者下属DOM元素的时候都带进去。这么一来，parseElement就变成一个递归了，于是它只好有两个参数，变成了这样：	function parseElement(element, vm) {		var model = vm;		if (element.getAttribute("vm-model")) {			model = bindModel(element.getAttribute("vm-model"));		}		for (var i=0; i<element.attributes.length; i++) {			parseAttribute(element, element.attributes[i], model);		}		for (var i=0; i<element.children.length; i++) {			parseElement(element.children[i], model);		}	}看看我们打算怎么来实例化这个模型，这个bindModel方法的参数是模块名，于是我们先去use一下，从工厂里生成出来，然后new一下，先这么return出去吧。	function bindModel(modelName) {		thin.log("model" + modelName);		var model = thin.use(modelName, true);		var instance = new model();		return instance;	}下面稍微有些麻烦的就是parseAttribute了，先挑最复杂的变量绑定来看。说复杂其实也不复杂，讲这个之前我们先来探讨一下从语言上怎么去实现数据绑定吧。先看从界面元素到变量，这个其实还是简单的，比如说把某个输入框绑定在变量上，那我们只要监听所有有可能让这个输入框内容发生变化的事件即可，比如按键输入，比如复制粘贴，在这些事件里面把对应的变量值改变一下。反过来怎么办呢，我们如何让一个变量改变的时候去把界面更新？在C#里面有一个特性叫做存取器，我们可以对一个属性定义存取器，存取器会被当做方法一样执行，在这里面，我们就可以做给绑定元素赋值的事了。如果没有这样的语法，我们给属性赋值只能这样：	Person.prototype.getName = function() {		return this.name	};	Person.prototype.setName = function(value) {		this.name = name;	};或者合并两个方法，只判断是否传了参数：	Person.prototype.name = function(value) {		if (arguments.length == 0) {			return this._name;		}		else {			this._name = value;		}	}这么做首先是自己的实现就比较麻烦，其次是别人用起来也很麻烦。比如他本来可以a.name = "aaa"的，现在要a.name("aaa")了。那JavaScript里面有没有类似索引器的特性呢？老早以前是没有的，但现在有了，那就是Object.defineProperty，它的第三个参数就是可选的存取函数。比如说：	Object.defineProperty(tom, "name", {		get: function() {			return this.lastName + "." + this.firstName;		}	});这时候获取tom.name，取得的就过就是通过get函数拼接出来的了，注意这里define的时候，是定义在实例上的，如果想要定义到类型里面，可以在构造器里面定义。现在我们就可以来写bindValue函数了：	function bindValue(element, key, vm) {		thin.log("binding value: " + key);		vm.$watch(key, function (value, oldValue) {			element.value = value || "";		});		element.onkeyup = function () {			vm[key] = element.value;		};		element.onpaste = function () {			vm[key] = element.value;		};	}我们假定每个模型实例上带有一个$watch方法，用于监控某变量的变化，可以传入一个监听函数，当变量变化的时候，自动调用这个函数，并且把新旧两个值传回来。在这个代码里，我们使用$watch方法给传入的key添加一个监听，监听器里面给监听元素赋值。我们这里偷懒了一下，假定所有的绑定元素都是输入框，所以直接给element.value设置值，为了防止值为空导致显示undefined，把值跟空字符串用短路表达式做了个转换。接下来，也对element的几个可能导致值变化的事件进行了监听，在里面把模型上对应的值更新掉。这样双向绑定就做好了。然后回头来看$watcher的实现。很显然这里也要一个map，我们给它取名为$watchers，存放属性的绑定关系，对于每个属性，它的值需要保存一份，供getter获取，同时还有一个数组，存放了该属性绑定的处理函数。当属性发生变更的时候，去挨个把它们调用一下。	var Binder = {		$watch: function (key, watcher) {			if (!this.$watchers[key]) {				this.$watchers[key] = {					value: this[key],					list: []				};				Object.defineProperty(this, key, {					set: function (val) {						var oldValue = this.$watchers[key].value;						this.$watchers[key].value = val;						for (var i = 0; i < this.$watchers[key].list.length; i++) {							this.$watchers[key].list[i](val, oldValue);						}					},					get: function () {						return this.$watchers[key].value;					}				});			}			this.$watchers[key].list.push(watcher);		}	};但是vm怎么就有$watcher呢，每个地方都去判断一下非空然后再去创建其实挺麻烦的，所以，这个属性我们可以直接在实例化模型的时候创建出来。	function bindModel(name) {		thin.log("binding model: " + name);		var model = thin.use(name, true);		var instance = new model().extend(Binder);		instance.$watchers = {};		return instance;	}看看这里的写法，为什么$watchers要额外设置，而$watch就可以放在Binder里面来extend呢？先解释extend干了什么，它做的是一个对象的浅拷贝，也就是说，把Binder的属性和方法都复制给了创建出来的model实例，注意，这个所谓的复制，如果是简单类型，那确实复制了，如果是引用类型，那复制的其实只是一个引用，所以如果$watchers也放在Binder里，不同的instance就共享一个$watchers，逻辑就是错误的。那为什么$watcher又可以放在这里复制呢？因为它是函数，它的this始终指向当前的执行主体，也就是说，如果放在instance1上执行，指向的就是instance1，放在instance2上执行，指向的就是instance2，我们利用这一点，就可以不用让每个实例都创建一份$watcher方法，而是共用同一个。同理，我们可以把enable，visible，init，click这些都做起来，init的执行时间放在扫描完vm-model那个element之下的所有DOM节点之后。嗯，我们是不是可以试一下了？来写个代码：	<!DOCTYPE html>	<html>	<head>		<title>Simple binding demo</title>		<meta charset="utf-8">		<meta name="viewport" content="width=device-width, initial-scale=1.0">		<meta name="description" content="binding">		<meta name="author" content="xu.fei@outlook.com">		<script type="text/javascript" src="../js/thin.js"></script>	</head>	<body>	<div vm-model="test.Person">		<input type="text" vm-value="name"/>		<input type="text" vm-value="age"/>		<input type="text" vm-value="age"/>		<input type="button" vm-click="growUp" value="Grow Up"/>	</div>	<div vm-model="test.Person" vm-init="init">		<input type="text" vm-value="name"/>		<input type="text" vm-value="age"/>		<input type="button" vm-click="growUp" value="Grow Up"/>	</div>	<script type="text/javascript">		thin.define("test.Person", [], function () {			function Person() {				this.name = "Tom";				this.age = 5;			}			Person.prototype = {				init: function () {					this.name = "Jerry";					this.age = 3;				},				growUp: function () {					this.age++;				}			};			return Person;		});	</script>	</body>	</html>或者访问这里：http://xufei.github.io/thin/demo/simple-binding.html以刚才文章提到的内容，还不能完全解释这个例子的效果，因为没看到在哪里调用parseElement的。说来也简单，就在thin.js里面，直接写了一个thin.ready，在那边调用了这个函数，去解析了document.body，于是测试页面里面才可以只写绑定和视图模型。