使用JavaScript创建模块化的双人对战象棋程序
====

#3. 怎么设计我们的象棋程序

##3.1. 模块的划分

按照我们在第一部分提到的思路，棋子应当是要承担一些职责的，那么，哪些事情适合交给棋子来做呢？

我们把走棋的这个过程分解，这里有四个部分：

- 判断我有没有可能出现在那个位置，比如说，象不能过河，老将和卫士不能出九宫格。
- 判断目标位置有没有己方棋子，如果有，也过不去。
- 判断能否直接到达目标位置，比如说，马腿是否被挡着了？象眼是否被塞着了？
- 移动过去，如果有对方棋子，吃掉它。

从第一步来看，这个过程不依赖于其他任何东西，每个棋子都应当能够牢记自己能去什么地方，不能去什么地方，只要你给它一个棋盘坐标，它自己是可以知道能不能去的。所以，这个职责我们放给棋子。

再看第二步，这个我们怎么判断呢？假设我们是一个士兵，在平原上打仗，我想知道前面山顶有没有人，怎么办？看了很多电影的我们表示，很好办。“总部总部，请侦察对面山顶。”所以，这个过程我们可以看到，检索目标位置不是棋子自身的职责，他只是调用了某个别的东西（己方司令部），得到了结果。

下面是第三步，这里面有可能不需要依赖于其他模块，也可能要依赖，怎么解释呢？比如说卫士，他走路只看距离，如果是他的合法可达位置，并且和当前位置距离的平方为1+1=2，那就可以直接过去，不需要依赖任何外部模块。但是如果是马，要先看距离的平方是不是1+4=5，然后再找马腿的位置，再去看那个位置有没有棋子。所以这种情况下，就要依赖外部模块。

第四步很简单，过去的时候发个通知给司令部，我换地方了！

于是，我们得出结论，棋子的职责应该是这些：判断自己是否可能出现在某位置；判断自己能否到达某位置；移动到某位置。


现在我们来考虑，谁来提供这个查询的服务，承担司令部的这些职责，很明显，这是一个全局唯一的东西，应当被设计成单例，在AngularJS中，这样的东西应当被定义为服务，所以我们有了一个chessService。

这个服务也有了我们需要的第一个方法：根据当前颜色，查询某个坐标是否有友军。既然我们可以查询，那应该需要有个地方存放当前棋局，而服务在整个AngularJS体系中已经位于最下层了，所以它除了依赖别的服务，不应当依赖其他类型的模块。这个象棋程序并不复杂，所以我们不打算再创建其他服务了，棋局就存放在这个服务内部，对外提供一系列方法供使用。

简单地考虑一下，我们的棋局应当能够：

- 初始化。初始化方法做的是把棋局恢复成初始状态，每次重新开局之前，我们可以这么做一下。

- 走棋。走棋是把给出的棋子移动到指定位置，如果目标位置没有别的棋子，只做移动，否则还要把对方杀死。走棋之前有一些判断条件，我们也把它们列出来。

* 列出某棋子的可达范围。这其实是一个辅助功能，当用户点击某棋子的时候，界面上能够标示出所有该棋子的可到达位置，便于用户选择，当用户选择其中某一个的时候，把棋子移动过去。

- 判断是否终局。每一步棋走完，我们都需要看一下是否有一方获胜，如果有，本局应当终止。

- 求和

#4. 代码实现

#4.1. 总体结构

#4.2. 具体实现



#5. 可能的改进

上面我们实现了一个可以在单机下双人对战的象棋程序，运行得还不错，但是我们想要给它一些增强，应当如何去做呢？

一个很典型的增强是，既然我们都做了单机的对战了，是不是可以搞一个服务端，变成联机的对战呢？当然可以，要做这个，我们唯一需要改动的代码是chessService，把初始化，走棋这些都改造成调用服务端的方法即可，从这里我们也可以看到如果代码进行了合理的分层，当需要改进的时候，对原代码改动有多么容易。

从另外一个方面看，如果我们不做服务端，而是想要本机开多个棋局，怎么办呢？我们来尝试一下。

在我们的考虑中，这应该非常容易，因为只需要多创建一个界面块，给它另外一个控制器实例就可以了，是不是这样呢？

很遗憾，事实有一些出入。原因在哪里？注意到我们的棋局存放在什么地方？在chessService里，它是用service定义的，这种方式决定了它是个单例，所以所有本机的期盼共享同一份棋局，为了避免这个问题，我们来把chessService改变一下，定义成factory。


#6. 总结

2004年，我花两天时间，用JavaScript和VML创建了一个单机双人象棋，并且作了简短的分析。在那个时代，没有AngularJS，没有BackBone，没有所有这些前端MV*框架。甚至没有jQuery，没有prototype，没有mootools，因此没有什么可借鉴的模块划分方式。我只好用很原始的办法，做了一种伪继承，实际是组合，来实现棋子和棋局之间的关系。

现在是2013年，9年过去了，Web的世界早已不是过去的样子，开发方式发生了翻天覆地的变化，我们有了Gmail，有了Google docs等等把Web技术应用到极致的优秀产品，有了asm.js、pdf.js等等让我们目瞪口呆的技术，更催生了各种MV*框架的兴起，我们有更多，更强大的方式去写Web程序。

最近我在写一个js框架，刚把模块化的部分写好，突发奇想，打算把之前写过的这个象棋在这个框架基础上重写一遍，并且作更深入的分析，以便使一些入门不久的读者得到帮助，同时也顺便检验我的新框架模块化是否是可用的。

另外一个方面，我们看到VML已经彻底衰落了，各种基于SVG和Canvas的绘图技术取代了它，因此在本例中，我们也与时俱进，改用SVG来绘制棋盘和棋子。RaphaelJS是一个很好的跨平台绘图库，它封装了SVG和VML，在能够使用SVG的浏览器中，它用SVG绘图，否则尝试使用VML，对于上层应用，操作绘图的API是毫无区别的，开发者不会感知到它的具体实现差别。

为了尽可能地把事情说得浅显一些，也尽量能分析得透彻，本文整合了我之前写过的一些文字。