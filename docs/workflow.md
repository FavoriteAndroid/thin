
##1.1. 面向对象

面向对象可以算是老生常谈了，在现代软件开发中，它是个主流的选择，相对于面向过程，有一些改进。

假设我们是上帝，要创造世界，因为这个过程太过复杂，无从入手，所以先从一件简单的事情看起。现在我们要设计一个方法，用于描述狼吃羊这个事情，某只狼吃了某只羊，你可以面向过程地吃，eat(狼A, 羊A)，也可以面向对象地吃，狼A.eat(羊A)。差别在哪里？只是写法有点变化。

好，那么我们帮上帝模拟整个生物界，这里面很多东西可以吃，大鱼吃小鱼，小鱼吃虾米，吃不吃皮，吐不吐骨头，这个时候再来修改这个eat函数，复杂吗？eat里面要判断很多东西，假如上帝很勤劳，所有代码都自己设计，那没关系，没太大区别，判断就判断呗。

假设上帝没足够精力来管理整个东西了，雇了一群天使来协助设计，每个人都来修改这个eat函数，当然可以拆分，wolfEatSheep(), tigerEatWolf()，然后在eat里面判断参数来分别调用，把函数分下去让每个人做，可以。

动物不光要做吃这个事情，要能跑能跳，会说会叫，又多了一堆函数，每个里面都这么判断，相当相当的烦。怎么办？我们来面向对象一下。

现在开始按照动物拆分，100个天使，每个天使创造一种动物。创造哪种动物，就站在哪种动物的角度考虑问题，我吃的时候怎么吃，跑的时候怎么跑，都跟别人无关，这么一来，每个人就专注多了。每个动物只关注我要怎么才能活着，不必站在上帝的角度考虑问题。这个过程，是类的划分过程，也就是封装的过程。

这时候，上帝觉得自然界光有动物是不行的，还要有植物，刚才说的这些都是动物，植物的特点跟动物有很大区别。假设你是上帝，为每种生物安排衣食住行，那是相当复杂的。偷懒吧，上帝说，植物们，你们自己生长吧，动物们，你们吃喝玩乐吧，假如能达到这个效果，那很省事。

上帝用一个循环来遍历所有动物，让他们吃喝玩乐，用另外一个循环让植物欣欣向荣。动物跟植物为什么要区别对待？因为它们不是同样的东西，能做的事情不同。所有动物派生于动物这个基础类型，从动物这个种类下，又分出各种纲，各种目，各种属。狮子是哺乳动物，猴子也是，但是狮子是猫科动物，猴子是灵长动物，这就构成了一个倒着的树状体系，一层一层形成继承关系。哺乳动物会喂奶，那么所有继承自哺乳动物的，都自动拥有这个特征。整个这一切，构成了继承链。

假设有一天由于变异出现了新物种，不必劳烦上帝关照，只要鉴别一下它属于什么类型，就知道能做什么事了，它的一举一动，都必然拥有它所继承的种类的特征。

这样就能描述生物界了吗？不，还有那么一些怪胎的存在。你认为哺乳动物都不会飞，那就错了，因为蝙蝠会飞。蝙蝠会飞是它自身的特性，并非继承自哺乳动物，但是“飞”这个动作，却非蝙蝠独有。如果把“飞”定义成接口，那就很美好了，蝙蝠实现了它的飞行接口，虽然内部实现跟鸟类有所不同，而且这并不影响它的哺乳动物特性。

总之，是否面向对象只是思维方式的不同。做一个软件，面向对象也能做，不面向对象也能做。我的观点，如果关注可维护性和协作性，从目前的角度，面向对象是很好的选择，它很自然，很优雅，优雅得只要打一个“.”，你就能想起来什么事能做，什么事不能做。

##1.2. 模型的职责划分

面向对象的一个基本原则是分而治之（Divide and Conquer），这种方法论提倡将程序模块化，各模块实现单独的功能，在统一的管理下协同工作，构成整个系统。

在具体实施的时候，又有两种倾向：将功能高度集中于主控制模块；将功能下放到各部件。这两种做法都有很高的可行性，也分别有大量支持者。我觉得在一些程度上，后者更贴近人类的思维方式，更适合用人性化的观念来解释。

将两种类型的程序对应到生物集群，第一种相当于一个蚁群，第二个相当于人群。蚁群的特点是，个体能够完成的事务非常有限，但是因为在一个非常强有力的统治者蚁后的控制下，它们能够协同工作，统一调度，完成不可想象的事件。人群的特点是，每个人都可以独立思考，能够理解别人的指令，并且根据这些指令做到力所能及的事情。作为人群的统治者，他的智慧不需要比其他人的高太多，只需要从宏观上来把握一些事情即可。

从系统的实现来说，第一种方式难度很高。完成单个蚂蚁（小模块）的功能并不复杂，创建大量的蚂蚁也只不过是需要的时间多一点，但是，当开始设计蚁后（总控模块）的时候，噩梦开始了，整个调度算法实在是一件令人头疼的事情。对于比较复杂一点的系统，让一个人去设计这个模块简直是不可思议，但是如果由多个人共同完成这个模块，又面临着互相理解的问题，每个人的思路都不相同，在努力协作的过程中，大量的时间被浪费在交流和意见的统一上。与此同时，制作蚂蚁的程序员日益烦躁，觉得自己的工作没有难度，无聊，士气低下……

换一种思路，从人类管理的角度来看问题。假设有一支庞大的军队（假设是一个集团军），司令官需要他的士兵列队，我们来为这个系统设计调度算法。先假设所有士兵跟蚂蚁一样笨，他们只能明白“站到司令部大门往东50米，往北100米的地方”这样的简单指令，请同情一下这位司令官，他不得不为每个士兵来指定一个位置，并且不得不研究列队的规则，他需要整天忙碌来完成这样一个庞大的任务（而且还不一定能完成）。他叹息道：哦，上帝……

让我们设法来减轻他的烦恼吧，目标是让每个人都主动参与这个事件，不再那么被动，大家都努力完成自己力所能及的工作。于是我们授权各级指挥官让他自己的士兵列队，这样一来，司令官的工作简单多了，他发布命令：各位军长请注意，我命令你们列队，按照番号顺序，分布到司令部门口的空地上（假设这个空地足够大，姑且认为能够容纳整个集团军），各军之间保持50米间隔。

接到命令以后，军长们开始忙碌，而司令官先生已经可以搬一把椅子坐到电话机旁，等待列队完毕的报告了。同样，军长要做的事情，也就是告诉属下的各位师长，让他们按照番号顺序列队，就这样，命令被传递到最下面一级。班长大喊：伙计们，按照个头排成一列，矮的在前面，高的在后面，前后间隔一米！于是，所有人站到了他应该站的位置，望着在短时间内迅速列队的整个集团军，司令官太满意了。

我们发现了什么？很显然，下放权力的方式要省事得多，更关键的是，它使得每个人都做一定的事情，但是又不成为负担。在设计者思路清晰化的同时，负责为系统每个部分编写代码的人员也更容易享受到编程的乐趣，就算是最低层的程序员也有了发挥自己才能、用自己的思路去影响系统的机会，而且，系统集成的过程将变得更加简单。

对于一名软件设计师来说，他的思想决定了他所设计出来的软件结构，将自己的灵魂注入到冰冷的代码中，这是一种艺术。然而，不同的人有不同的风格，设计者对于世界的认知方式不同，他们对于同样的需求，可能采用的设计方式也多种多样。